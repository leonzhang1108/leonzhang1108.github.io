{"version":3,"sources":["webpack:///./src/pages/MusicVisualizer/visualizer.ts"],"names":["draw","size","volume","currentTime","initAC","ac","AudioContext","gainNode","createGain","gain","value","connect","destination","analyser","createAnalyser","fftSize","load","url","callback","progressCb","abort","responseType","onDownloadProgress","v","loaded","total","cancelToken","CancelToken","c","axiosCancellation","then","response","data","catch","thrown","isCancel","console","log","message","play","src","cb","n","count","source","stop","decodeCallback","buffer","createBufferSource","e","ArrayBuffer","decodeAudioData","arrayBuffer","start","bufferSource","loop","visualize","updateVolume","vol","arr","Uint8Array","frequencyBinCount","raf","window","requestAnimationFrame","fn","getByteFrequencyData","rafId","setCurrent","curr","setInterval","isFirst","interval","clearInterval","setCurrTime","duration","toFixed","pause","suspend","cancelAnimationFrame","resume","close","this"],"mappings":"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","file":"js/41.f3e1d16b7c5421a1ad9c.bundle.js","sourcesContent":["import Axios from 'axios'\n\nexport default class Visualizer {\n  source\n  count\n  ac\n  draw\n  size\n  gainNode\n  analyser\n  rafId\n  volume\n  buffer\n  currentTime\n  curr\n  total\n  interval\n  axiosModel\n  axiosCancellation\n\n  constructor({ draw, size, volume, currentTime }) {\n    this.source = null\n    this.count = 0\n    this.draw = draw\n    this.size = size\n    this.volume = volume\n    this.currentTime = currentTime\n    this.initAC()\n  }\n\n  initAC = () => {\n    this.ac = new AudioContext()\n    this.gainNode = this.ac.createGain()\n    this.gainNode.gain.value = this.volume\n    this.gainNode.connect(this.ac.destination)\n    this.analyser = this.ac.createAnalyser()\n    this.analyser.fftSize = this.size * 2\n    this.analyser.connect(this.gainNode)\n  }\n\n  load = (url, callback, progressCb) => {\n    this.abort()\n    Axios({\n      url,\n      responseType: 'arraybuffer',\n      onDownloadProgress: v => {\n        const { loaded, total } = v\n        progressCb((loaded / total) * 100)\n      },\n      cancelToken: new Axios.CancelToken(c => {\n        this.axiosCancellation = c\n      })\n    })\n      .then(response => {\n        callback(response.data)\n      })\n      .catch(thrown => {\n        if (Axios.isCancel(thrown)) {\n          console.log('Request canceled', thrown.message)\n        } else {\n          progressCb('error')\n        }\n      })\n  }\n\n  abort = () => this.axiosCancellation && this.axiosCancellation('abort')\n\n  play = ({ src, cb, progressCb }) => {\n    const n = ++this.count\n    if (this.source) {\n      this.source.stop()\n    }\n    const decodeCallback = buffer => {\n      this.buffer = buffer\n      if (n === this.count && this.ac) {\n        try {\n          this.createBufferSource({ buffer }, cb)\n        } catch (e) {\n          console.log(e)\n        }\n      }\n    }\n    if (src instanceof ArrayBuffer) {\n      this.ac.decodeAudioData(src, decodeCallback)\n    } else {\n      this.load(\n        src,\n        arrayBuffer => {\n          this.ac.decodeAudioData(arrayBuffer, decodeCallback)\n        },\n        progressCb\n      )\n    }\n  }\n\n  createBufferSource = ({ buffer, start = 0 }, cb?) => {\n    if (this.source) {\n      this.source.stop()\n    }\n    if (!this.buffer) {\n      return\n    }\n    const bufferSource = this.ac.createBufferSource()\n    bufferSource.buffer = this.buffer = buffer\n    bufferSource.loop = true\n    bufferSource.connect(this.analyser)\n    bufferSource.start(0, start)\n    this.source = bufferSource\n    this.visualize()\n    if (cb) {\n      cb()\n    }\n  }\n\n  updateVolume = vol => {\n    console.log(vol)\n    this.gainNode.gain.value = this.volume = vol\n  }\n\n  visualize = () => {\n    const arr = new Uint8Array(this.analyser.frequencyBinCount)\n    const raf = window.requestAnimationFrame\n    const fn = () => {\n      this.analyser.getByteFrequencyData(arr)\n      this.draw(arr, this.volume)\n      this.rafId = raf(fn)\n    }\n    fn()\n  }\n\n  setCurrent = (start = 0) => {\n    const { buffer } = this\n    this.curr = 0\n    this.createBufferSource({ buffer, start })\n    this.setInterval(true)\n  }\n\n  setInterval = (isFirst?) => {\n    if (this.interval) {\n      clearInterval(this.interval)\n    }\n    if (isFirst) {\n      this.setCurrTime(isFirst)\n    }\n    this.interval = setInterval(() => {\n      this.setCurrTime()\n    }, 1000)\n  }\n\n  setCurrTime = (isFirst?) => {\n    const total = this.buffer ? this.buffer.duration.toFixed(0) : 0\n    this.currentTime({ curr: isFirst ? 0 : ++this.curr, total })\n  }\n\n  pause = () => {\n    this.ac.suspend()\n    window.cancelAnimationFrame(this.rafId)\n    if (this.interval) {\n      clearInterval(this.interval)\n    }\n  }\n\n  resume = () => {\n    this.ac.resume()\n    this.visualize()\n    this.setInterval()\n  }\n\n  stop = () => {\n    this.abort()\n    this.ac.close()\n    window.cancelAnimationFrame(this.rafId)\n  }\n}\n"],"sourceRoot":""}