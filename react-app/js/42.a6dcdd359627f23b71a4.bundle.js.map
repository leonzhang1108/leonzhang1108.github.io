{"version":3,"sources":["webpack:///./src/pages/MusicVisualizer/visualizer.ts"],"names":["__webpack_require__","r","__webpack_exports__","axios__WEBPACK_IMPORTED_MODULE_0__","axios__WEBPACK_IMPORTED_MODULE_0___default","n","Visualizer","_a","_this","this","draw","size","volume","currentTime","initAC","ac","AudioContext","gainNode","createGain","gain","value","connect","destination","analyser","createAnalyser","fftSize","load","url","callback","progressCb","abort","responseType","onDownloadProgress","v","loaded","total","cancelToken","a","CancelToken","c","axiosCancellation","then","response","data","catch","thrown","isCancel","console","log","message","play","src","cb","count","source","stop","decodeCallback","buffer","createBufferSource","e","ArrayBuffer","decodeAudioData","arrayBuffer","_b","start","bufferSource","loop","visualize","updateVolume","vol","arr","Uint8Array","frequencyBinCount","raf","window","requestAnimationFrame","fn","getByteFrequencyData","rafId","setCurrent","curr","setInterval","isFirst","interval","clearInterval","setCurrTime","duration","toFixed","pause","suspend","cancelAnimationFrame","resume","close"],"mappings":"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","file":"js/42.a6dcdd359627f23b71a4.bundle.js","sourcesContent":["import Axios from 'axios'\n\nexport default class Visualizer {\n  source\n  count\n  ac\n  draw\n  size\n  gainNode\n  analyser\n  rafId\n  volume\n  buffer\n  currentTime\n  curr\n  total\n  interval\n  axiosModel\n  axiosCancellation\n\n  constructor ({ draw, size, volume, currentTime }) {\n    this.source = null\n    this.count = 0\n    this.draw = draw\n    this.size = size\n    this.volume = volume\n    this.currentTime = currentTime\n    this.initAC()\n  }\n\n  initAC = () => {\n    this.ac = new AudioContext()\n    this.gainNode = this.ac.createGain()\n    this.gainNode.gain.value = this.volume\n    this.gainNode.connect(this.ac.destination)\n    this.analyser = this.ac.createAnalyser()\n    this.analyser.fftSize = this.size * 2\n    this.analyser.connect(this.gainNode)\n  }\n\n  load = (url, callback, progressCb) => {\n    this.abort()\n    Axios({\n      url,\n      responseType: 'arraybuffer',\n      onDownloadProgress: v => {\n        const { loaded, total } = v\n        progressCb(loaded / total * 100)\n      },\n      cancelToken: new Axios.CancelToken(c => {\n        this.axiosCancellation = c\n      })\n    }).then(response => {\n      callback(response.data)\n    }).catch(thrown => {\n      if (Axios.isCancel(thrown)) {\n        console.log('Request canceled', thrown.message)\n      } else {\n        progressCb('error')\n      }\n    })\n  }\n\n  abort = () => this.axiosCancellation && this.axiosCancellation('abort')\n\n  play = ({ src, cb, progressCb }) => {\n    const n = ++this.count\n    if (this.source) {\n      this.source.stop()\n    }\n    const decodeCallback = buffer => {\n      this.buffer = buffer\n      if (n === this.count && this.ac) {\n        try {\n          this.createBufferSource({ buffer }, cb)\n        } catch (e) {\n          console.log(e)\n        }\n      }\n    }\n    if (src instanceof ArrayBuffer) {\n      this.ac.decodeAudioData(src, decodeCallback)\n    } else {\n      this.load(src, arrayBuffer => {\n        this.ac.decodeAudioData(arrayBuffer, decodeCallback)\n      }, progressCb)\n    }\n  }\n\n  createBufferSource = ({ buffer, start = 0 }, cb?) => {\n    if (this.source) { this.source.stop() }\n    if (!this.buffer) { return }\n    const bufferSource = this.ac.createBufferSource()\n    bufferSource.buffer = this.buffer = buffer\n    bufferSource.loop = true\n    bufferSource.connect(this.analyser)\n    bufferSource.start(0, start)\n    this.source = bufferSource\n    this.visualize()\n    if (cb) { cb() }\n  }\n\n  updateVolume = vol => {\n    console.log(vol)\n    this.gainNode.gain.value = this.volume = vol\n  }\n\n  visualize = () => {\n    const arr = new Uint8Array(this.analyser.frequencyBinCount)\n    const raf = window.requestAnimationFrame\n    const fn = () => {\n      this.analyser.getByteFrequencyData(arr)\n      this.draw(arr, this.volume)\n      this.rafId = raf(fn)\n    }\n    fn()\n  }\n\n  setCurrent = (start = 0) => {\n    const { buffer } = this\n    this.curr = 0\n    this.createBufferSource({ buffer, start })\n    this.setInterval(true)\n  }\n\n  setInterval = (isFirst?) => {\n    if (this.interval) { clearInterval(this.interval) }\n    if (isFirst) { this.setCurrTime(isFirst) }\n    this.interval = setInterval(() => {\n      this.setCurrTime()\n    }, 1000)\n  }\n\n  setCurrTime = (isFirst?) => {\n    const total = this.buffer ? this.buffer.duration.toFixed(0) : 0\n    this.currentTime({ curr: isFirst ? 0 : ++this.curr , total })\n  }\n\n  pause = () => {\n    this.ac.suspend()\n    window.cancelAnimationFrame(this.rafId)\n    if (this.interval) { clearInterval(this.interval) }\n  }\n\n  resume = () => {\n    this.ac.resume()\n    this.visualize()\n    this.setInterval()\n  }\n\n  stop = () => {\n    this.abort()\n    this.ac.close()\n    window.cancelAnimationFrame(this.rafId)\n  }\n}\n"],"sourceRoot":""}