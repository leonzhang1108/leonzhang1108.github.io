<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>前端面试升级 | Leonzhang&#39;s blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="All Hail JLA" />
  

  <meta name="description" content="AMD &amp;amp; CMD// CMD// 延迟执行// 代码运行时不知道依赖，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能define(function(require, exports, module) &amp;#123;     var a = require(&apos;./a&apos;)     a.">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试升级">
<meta property="og:url" content="http://6rina.cc/2017/09/07/fe-interview/index.html">
<meta property="og:site_name" content="Leonzhang&#39;s blog">
<meta property="og:description" content="AMD &amp;amp; CMD// CMD// 延迟执行// 代码运行时不知道依赖，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能define(function(require, exports, module) &amp;#123;     var a = require(&apos;./a&apos;)     a.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-11-04T18:19:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试升级">
<meta name="twitter:description" content="AMD &amp;amp; CMD// CMD// 延迟执行// 代码运行时不知道依赖，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能define(function(require, exports, module) &amp;#123;     var a = require(&apos;./a&apos;)     a.">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>




<div class="content content-post CENTER">
   <article id="post-fe-interview" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">前端面试升级</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.09.07</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Leon Zhang</span>
        </span>
      

      


      
        <span>
          <i class="icon-comment"></i>
          <a href="http://leonzh.cc/2017/09/07/fe-interview/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h3 id="AMD-amp-CMD"><a href="#AMD-amp-CMD" class="headerlink" title="AMD &amp; CMD"></a>AMD &amp; CMD</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="comment">// 延迟执行</span></span><br><span class="line"><span class="comment">// 代码运行时不知道依赖，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>) </span><br><span class="line">    a.doSomething() </span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) </span><br><span class="line">    b.doSomething() </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="comment">// 提前执行</span></span><br><span class="line"><span class="comment">// 在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; </span><br><span class="line">    a.doSomething() </span><br><span class="line">    b.doSomething() </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于软依赖的处理，推荐依赖前置+回调函数的实现形式</span></span><br><span class="line"><span class="keyword">if</span>(status)&#123; </span><br><span class="line">    <span class="keyword">async</span>([<span class="string">'a'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123; </span><br><span class="line">        a.doSomething() </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>-</th>
<th style="text-align:center">CMD(seajs)</th>
<th style="text-align:right">AMD(requirejs)</th>
</tr>
</thead>
<tbody>
<tr>
<td>对于依赖的模块</td>
<td style="text-align:center">延迟执行(异步require)</td>
<td style="text-align:right">提前执行(同步require)</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">依赖就近</td>
<td style="text-align:right">依赖前置 </td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">API 严格区分，推崇职责单一</td>
<td style="text-align:right">API 默认是一个当多个用</td>
</tr>
</tbody>
</table>
<h3 id="react-virtual-dom"><a href="#react-virtual-dom" class="headerlink" title="react virtual dom"></a>react virtual dom</h3><blockquote>
<p>在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何 进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前 整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟 DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化，而如果通过手动控 制，这种逻辑通常是极其复杂的。尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是 Diff部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要 关心在任意一个数据状态下，整个界面是如何Render的。</p>
</blockquote>
<h3 id="react-v-dom-渲染流程"><a href="#react-v-dom-渲染流程" class="headerlink" title="react v-dom 渲染流程"></a>react v-dom 渲染流程</h3><ul>
<li>Javascript DOM模型树（VTree），类似文档节点树（DOM）</li>
<li>DOM模型树转节点树方法（VTree -&gt; DOM）</li>
<li>两个DOM模型树的差异算法（diff(VTree, VTree) -&gt; PatchObject）</li>
<li>根据差异操作节点方法（patch(DOMNode, PatchObject) -&gt; DOMNode）</li>
</ul>
<h3 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h3><blockquote>
<p><strong>componentWillMount()</strong>: render之前，setState不会触发重新渲染，server render时唯一调用的钩子，通常用constructor替代<br><strong>render(</strong>): 渲染<br><strong>comoinentDidMount()</strong>: render之后，可进行dom操作，异步加载，setState后重新渲染<br><strong>componentWillReceiveProps(nextProps)</strong>: componentDidMount之后，在已经挂在的组件接收到新props时触发</p>
<ul>
<li>比较this.props和nextProps，改变this.state</li>
<li>this.setState()方法不会触发componentWillReceiveProps()</li>
</ul>
</blockquote>
<blockquote>
<p><strong>shouldComponentUpdate(nextProps, nextState)</strong>: 在接收到新props或state时，或者说在componentWillReceiveProps(nextProps)后触发</p>
<ul>
<li>return true 重新渲染 return false 不重新渲染且之后生命周期不触发</li>
<li>forceUpdate()和首次渲染时不触发</li>
</ul>
</blockquote>
<blockquote>
<p><strong>componentWillUpdate(nextProps, nextState)</strong>: shouldComponentUpdate之后触发，render之前调用，初始化时不调用</p>
<ul>
<li><strong>不能用this.setState()</strong></li>
</ul>
</blockquote>
<blockquote>
<p><strong>componentDidUpdate(prevProps, prevState)</strong>: componentWillUpdate(nextProps, nextState)或更新之后调用，初始化不调用</p>
<ul>
<li>可操作dom，可以触发网络请求</li>
</ul>
</blockquote>
<blockquote>
<p><strong>componentWillUnmount()</strong>: 组件销毁或卸载之前触发</p>
<ul>
<li>清理timers, intervals或者取消网络请求等</li>
</ul>
</blockquote>
<h3 id="setState-之后发生了什么"><a href="#setState-之后发生了什么" class="headerlink" title="setState 之后发生了什么"></a>setState 之后发生了什么</h3><blockquote>
<p>React会将当前参数与组件当前状态进行合并，触发调和，根据新的状态构建React元素，计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染</p>
</blockquote>
<h3 id="什么情况下你会优先选择使用-Class-Component-而不是-Functional-Component"><a href="#什么情况下你会优先选择使用-Class-Component-而不是-Functional-Component" class="headerlink" title="什么情况下你会优先选择使用 Class Component 而不是 Functional Component"></a>什么情况下你会优先选择使用 Class Component 而不是 Functional Component</h3><blockquote>
<p>包含<strong>内部状态</strong>或者使用到<strong>生命周期函数</strong></p>
</blockquote>
<h3 id="React-中-keys-的作用是什么"><a href="#React-中-keys-的作用是什么" class="headerlink" title="React 中 keys 的作用是什么"></a>React 中 keys 的作用是什么</h3><blockquote>
<p>追踪哪些列表中元素被修改、被添加或者被移除的辅助标识，从而减少不必要的元素重渲染</p>
</blockquote>
<h3 id="回调渲染模式"><a href="#回调渲染模式" class="headerlink" title="回调渲染模式"></a>回调渲染模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Twitter username=<span class="string">'leonzhang'</span>&gt;</span><br><span class="line">  &#123;(user) =&gt; user === <span class="literal">null</span></span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Badge info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> fetchUser <span class="keyword">from</span> <span class="string">'twitter'</span></span><br><span class="line"><span class="comment">// fetchUser take in a username returns a promise</span></span><br><span class="line"><span class="comment">// which will resolve with that username's data.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// finish this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回调渲染"><a href="#回调渲染" class="headerlink" title="回调渲染"></a>回调渲染</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> fetchUser <span class="keyword">from</span> <span class="string">'twitter'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: <span class="literal">null</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    username: PropTypes.string.isRequired,</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    fetchUser(<span class="keyword">this</span>.props.username)</span><br><span class="line">      .then(<span class="function">(<span class="params">user</span>) =&gt;</span> <span class="keyword">this</span>.setState(&#123;user&#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传入-setState-函数的第二个参数的作用是什么"><a href="#传入-setState-函数的第二个参数的作用是什么" class="headerlink" title="传入 setState 函数的第二个参数的作用是什么"></a>传入 setState 函数的第二个参数的作用是什么</h3><blockquote>
<p>可以用该函数来监听渲染是否完成<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'tylermcginnis33'</span> &#125;,</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'setState has finished and the component has re-rendered.'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>同步修改state<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="常见开发漏洞"><a href="#常见开发漏洞" class="headerlink" title="常见开发漏洞"></a>常见开发漏洞</h3><ul>
<li>xss(cross site scripting): 攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</li>
<li>sql注入: 用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。</li>
</ul>
<!-- ### BFC, IFC, GFC 和 FFC
> aka Block Formatting Contexts, Inline FC, GridLayout FC, Flex FC. 
> BFC: 块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素
> * 如何产生BFC: float不为none, overflow不为visible, position不为static或relative, display为table-cell, table-caption, inline-block -->
<h3 id="DNS原理"><a href="#DNS原理" class="headerlink" title="DNS原理"></a>DNS原理</h3><ul>
<li>发送域名解析请求，发送本地域名服务器</li>
<li>本地域名服务器若有本地缓存，返回结果，没有缓存，请求上级域名服务器</li>
<li>以此类推，直到找到，返回域名，并缓存在路径中路过的域名服务器中</li>
</ul>
<h3 id="html5语义化优势"><a href="#html5语义化优势" class="headerlink" title="html5语义化优势"></a>html5语义化优势</h3><ul>
<li>无css情况下也能呈现结构</li>
<li>title、alt用于解释名词或解释图片信息、label标签的活用，增加用户体验</li>
<li>利于SEO优化</li>
<li>方便其它设备解析</li>
<li>便于维护</li>
</ul>
<h3 id="哪些语义化标签"><a href="#哪些语义化标签" class="headerlink" title="哪些语义化标签"></a>哪些语义化标签</h3><blockquote>
<p>header, footer, article, nav, aside, section…</p>
</blockquote>
<h3 id="jsonp，getJSON-getScript"><a href="#jsonp，getJSON-getScript" class="headerlink" title="jsonp，getJSON(),getScript()"></a>jsonp，getJSON(),getScript()</h3><blockquote>
<p>Jsonp: 解决跨域问题。允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据<br>getScript(): </p>
<ul>
<li>客户端: jQuery.getScript(url, () =&gt; console.log(result))</li>
<li>服务端: var result = { name: ‘leonzhang’ }</li>
</ul>
</blockquote>
<h3 id="定义JS类"><a href="#定义JS类" class="headerlink" title="定义JS类"></a>定义JS类</h3><blockquote>
<p>构造函数法：js<strong>类</strong>的定义方法和<strong>函数</strong>的定义方法一样，所以<em>定义</em>了<strong>构造函数</strong>就<em>定义</em>了<strong>类</strong>，<strong>构造函数</strong>内的<em>方法和属性</em>也就是<strong>类</strong>中的<em>方法和属性</em></p>
</blockquote>
<h3 id="Set和WeakSet"><a href="#Set和WeakSet" class="headerlink" title="Set和WeakSet"></a>Set和WeakSet</h3><blockquote>
<p>Set<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受数组 去重</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]);</span><br><span class="line">[...s]</span><br><span class="line"><span class="comment">// Set.prototype.size:返回Set实例的成员数量。 </span></span><br><span class="line"><span class="comment">// Set.prototype.constructor:默认的构造Set函数。</span></span><br><span class="line"><span class="comment">// 由于Set没有键名，只有值名，keys()和values()返回的结果是一样</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> set.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//red,green,blue</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> set.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//red,green,blue</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> set.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set实现并集，交集，差集</span></span><br><span class="line"><span class="keyword">let</span> set1  = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br><span class="line"><span class="keyword">let</span> set2  = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]);</span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1, ...set2]);</span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1].filter(<span class="function"><span class="params">x</span> =&gt;</span> set2.has(x)));</span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1].filter(<span class="function"><span class="params">x</span> =&gt;</span> !set2.has(x)));</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>WeakSet</p>
<ul>
<li>它只能用于存储对象 而不能是其他类型的值</li>
<li>不能遍历，是因为成员都是弱引用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line">ws.add(<span class="built_in">window</span>);</span><br><span class="line">ws.add(obj);</span><br><span class="line">ws.has(<span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">ws.has(foo); <span class="comment">//false</span></span><br><span class="line">ws.delete(<span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">ws.has(<span class="built_in">window</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><blockquote>
<p>如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。<br>Symbol是原始数据类型，表示独一无二的值</p>
</blockquote>
<h3 id="JS继承（6种）"><a href="#JS继承（6种）" class="headerlink" title="JS继承（6种）"></a>JS继承（6种）</h3><blockquote>
<p><strong>简单原型链继承</strong></p>
<ul>
<li>优点: 简单</li>
<li>缺点: 1. 来自原型对象的引用属性是所有实例共享的 2. 创建子类实例时，无法向父类构造函数传参<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.job = <span class="string">'super hero'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Robin</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Robin.prototype = <span class="keyword">new</span> Batman()</span><br><span class="line"><span class="keyword">var</span> robin = <span class="keyword">new</span> Robin()</span><br><span class="line"><span class="built_in">console</span>.log(robin.job)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>构造函数</strong> </p>
<ul>
<li>优点: 修复简单原型链的缺点</li>
<li>缺点: 无法实现函数复用，内存爆炸<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">    <span class="keyword">this</span>.job = <span class="string">'super hero'</span></span><br><span class="line">    <span class="keyword">this</span>.roar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'ironman sucks'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Robin</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    Batman.call(<span class="keyword">this</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> robin = <span class="keyword">new</span> Robin()</span><br><span class="line"><span class="built_in">console</span>.log(robin.roar())</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>组合继承(最常用)</strong></p>
<ul>
<li>优点: 不存在共享，可传参，函数可复用</li>
<li>缺点: 子类原型上有一份多余的父类实例属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">    <span class="keyword">this</span>.job = <span class="string">'super hero'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  在此处声明函数</span></span><br><span class="line">Batman.prototype.roar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'ironman sucks'</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Robin</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    Batman.call(<span class="keyword">this</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> robin = <span class="keyword">new</span> Robin()</span><br><span class="line">robin.roar()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>寄生组合继承（最佳）</strong></p>
<ul>
<li>优点: 完美</li>
<li>缺点: 麻烦<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>)</span>&#123;   <span class="comment">// 生孩子函数 beget：龙beget龙，凤beget凤。</span></span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 只在此处声明基本属性和引用属性</span></span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  在此处声明函数</span></span><br><span class="line">Batman.prototype.roar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'ironman sucks'</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Robin</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    Batman.call(<span class="keyword">this</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下三行重点</span></span><br><span class="line"><span class="keyword">var</span> proto = beget(Batman.prototype)</span><br><span class="line">proto.constructor = Robin</span><br><span class="line">Robin.prototype = proto</span><br><span class="line"><span class="keyword">var</span> robin = <span class="keyword">new</span> Robin()</span><br><span class="line">robin.roar()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>原型式</strong></p>
<ul>
<li>优点: 从已有对象衍生新对象，不需要创建自定义类型</li>
<li>缺点: 无法实现代码复用，原型引用属性会被所有实例共享<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> batman = <span class="keyword">new</span> Batman()</span><br><span class="line"><span class="keyword">var</span> robin = beget(batman)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>寄生式</strong></p>
<ul>
<li>优点: 不需要创建自定义类型</li>
<li>缺点: 无法实现函数复用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">    <span class="keyword">this</span>.roar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'ironman sucks'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSubObject</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建新对象</span></span><br><span class="line">    <span class="keyword">var</span> clone = beget(obj) <span class="comment">// 核心</span></span><br><span class="line">    <span class="comment">// 增强</span></span><br><span class="line">    clone.attr1 = <span class="number">1</span></span><br><span class="line">    clone.attr2 = <span class="number">2</span></span><br><span class="line">    <span class="comment">//clone.attr3...</span></span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> robin = getSubObject(<span class="keyword">new</span> Batman())</span><br><span class="line">robin.roar()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">returnFun</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(a + b)</span><br><span class="line">    &#125;</span><br><span class="line">    returnFun.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnFun</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString()) <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deepCopy = <span class="function"><span class="keyword">function</span> (<span class="params">sourceObj</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;,</span><br><span class="line">        key = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">//当前属性</span></span><br><span class="line">        curSourceKey = <span class="literal">null</span>,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = <span class="number">0</span>,</span><br><span class="line">        toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> sourceObj) &#123;</span><br><span class="line">        curSourceKey = sourceObj[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> curSourceKey !== <span class="string">"object"</span>) &#123;</span><br><span class="line">            result[key] = curSourceKey;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (toString.apply(curSourceKey) === <span class="string">"[object Object]"</span>) &#123;</span><br><span class="line">            result[key] = deepCopy(sourceObj[key]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (toString.apply(curSourceKey) === <span class="string">"[object Array]"</span>) &#123;</span><br><span class="line"></span><br><span class="line">            result[key] = [];</span><br><span class="line">            <span class="keyword">for</span> (len = curSourceKey.length; i &lt; len; i++) &#123;</span><br><span class="line">                result[key][i] = curSourceKey[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mixin-多重继承"><a href="#mixin-多重继承" class="headerlink" title="mixin (多重继承)"></a>mixin (多重继承)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...objs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objs.reduce(<span class="function">(<span class="params">dest, src</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> src) &#123;</span><br><span class="line">            dest[key] = src[key]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dest;    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dest = mixin(&#123;...&#125;, src1, src2, src3);</span><br></pre></td></tr></table></figure>
<h4 id="es5"><a href="#es5" class="headerlink" title="es5"></a>es5</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWithPrototype</span>(<span class="params">Cls</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> P = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    P.prototype = Cls.prototype;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, age, gender, level, salary</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age, gender);</span><br><span class="line">    <span class="keyword">this</span>.level = level;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype = createWithPrototype(Person);</span><br><span class="line"></span><br><span class="line">mixin(Employee.prototype, &#123;</span><br><span class="line">    getSalary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Serializable</span>(<span class="params">Cls, serializer</span>)</span>&#123;</span><br><span class="line">    mixin(Cls, serializer);</span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Cls.stringify(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixin(Employee.prototype, <span class="keyword">new</span> Serializable(Employee, &#123;</span><br><span class="line">        parse: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Employee(</span><br><span class="line">                data.name,</span><br><span class="line">                data.age,</span><br><span class="line">                data.gender,</span><br><span class="line">                data.level,</span><br><span class="line">                data.salary</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">        stringify: <span class="function"><span class="keyword">function</span>(<span class="params">employee</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                name: employee.name,</span><br><span class="line">                age: employee.age,</span><br><span class="line">                gender: employee.gender,</span><br><span class="line">                level: employee.level,</span><br><span class="line">                salary: employee.salary</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> Employee(<span class="string">"jane"</span>,<span class="number">25</span>,<span class="string">"f"</span>,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> employee2 = Employee.parse(employee+<span class="string">""</span>); <span class="comment">//通过序列化反序列化复制对象</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(employee2, </span><br><span class="line">    employee2 <span class="keyword">instanceof</span> Employee,    <span class="comment">//true </span></span><br><span class="line">    employee2 <span class="keyword">instanceof</span> Person,    <span class="comment">//true</span></span><br><span class="line">    employee == employee2);        <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h4 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Serializable = <span class="function"><span class="params">Sup</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Sup</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args)&#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.constructor.stringify !== <span class="string">"function"</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"Please define stringify method to the Class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.constructor.parse !== <span class="string">"function"</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"Please define parse method to the Class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructor.stringify(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, gender)&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;name, age, gender&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Serializable</span>(<span class="title">Person</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, gender, level, salary)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age, gender);</span><br><span class="line">    <span class="keyword">this</span>.level = level;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// static 直接类调用方法</span></span><br><span class="line">  <span class="keyword">static</span> stringify(employee)&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;name, age, gender, level, salary&#125; = employee;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(&#123;name, age, gender, level, salary&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> parse(str)&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Employee(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">"jane"</span>,<span class="number">25</span>,<span class="string">"f"</span>,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">let</span> employee2 = Employee.parse(employee+<span class="string">""</span>); <span class="comment">//通过序列化反序列化复制对象</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(employee2, </span><br><span class="line">  employee2 <span class="keyword">instanceof</span> Employee,  <span class="comment">//true </span></span><br><span class="line">  employee2 <span class="keyword">instanceof</span> Person,  <span class="comment">//true</span></span><br><span class="line">  employee == employee2);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承原生Set</span></span><br><span class="line"><span class="keyword">const</span> Serializable = <span class="function"><span class="params">Sup</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Sup</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args)&#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.constructor.stringify !== <span class="string">"function"</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"Please define stringify method to the Class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.constructor.parse !== <span class="string">"function"</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"Please define parse method to the Class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructor.stringify(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span> <span class="keyword">extends</span> <span class="title">Serializable</span>(<span class="title">Set</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> stringify(s)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...s]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> parse(data)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MySet(<span class="built_in">JSON</span>.parse(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> MySet([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">let</span> s2 = MySet.parse(s1 + <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2,         <span class="comment">//Set&#123;1,2,3,4&#125;</span></span><br><span class="line">            s1 == s2);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h4 id="序列化-amp-不可变-immutable"><a href="#序列化-amp-不可变-immutable" class="headerlink" title="序列化 &amp; 不可变(immutable)"></a>序列化 &amp; 不可变(immutable)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Serializable = <span class="function"><span class="params">Sup</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Sup</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args)&#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.constructor.stringify !== <span class="string">"function"</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"Please define stringify method to the Class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.constructor.parse !== <span class="string">"function"</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"Please define parse method to the Class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructor.stringify(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> Immutable = <span class="function"><span class="params">Sup</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Sup</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args)&#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">    <span class="built_in">Object</span>.freeze(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Immutable</span>(<span class="title">Serializable</span>(<span class="title">Array</span>))</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> stringify(arr)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">Immutable</span>:arr&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> parse(data)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyArray(...JSON.parse(data).Immutable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> arr2 = MyArray.parse(arr1 + <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1, arr2, </span><br><span class="line">    arr1+<span class="string">""</span>,     <span class="comment">//&#123;"Immutable":[1,2,3,4]&#125;</span></span><br><span class="line">    arr1 == arr2);</span><br><span class="line"> </span><br><span class="line">arr1.push(<span class="number">5</span>); <span class="comment">//throw Error!</span></span><br></pre></td></tr></table></figure>
<h3 id="instanceof-和-typeof"><a href="#instanceof-和-typeof" class="headerlink" title="instanceof 和 typeof"></a>instanceof 和 typeof</h3><blockquote>
<p>用来判断变量</p>
<ul>
<li><code>typeof</code> 返回类型: number,boolean,string,object,undefined,function <strong>不能判断数组</strong><br>eg: <code>typeof(1)</code><br>判断变量是否存在：<code>if(typeof a != &#39;undefined&#39;)</code></li>
<li><code>instanceof</code>返回布尔值，只能用来判断<strong>函数</strong>, <strong>对象</strong>和<strong>数组</strong>，不能判断字符串数字等等，检测对象的原型链是否指向构造函数的prototype对象<br>eg:  <code>var a = &#39;123&#39;; console.log(a instanceof String); //false</code><br><strong>判断数组终极方案</strong><br><code>Object.prototype.toString.call(obj) === &quot;[object Array]&quot;</code></li>
</ul>
</blockquote>
<h3 id="三次握手-四次撒手"><a href="#三次握手-四次撒手" class="headerlink" title="三次握手 四次撒手"></a>三次握手 四次撒手</h3><blockquote>
<p>三次握手</p>
<ul>
<li>客户端发送SYN=1，且发送随机seq</li>
<li>服务器受到SYN=1，返回一个ACK=1（表示确认），并同返回一个请求连接SYN=1，然后返回一个ack=seq+1（客户端随机码应答），且自己也返回一个seq（随机码）</li>
<li>客户端收到服务器的ack后验证，向服务器确认包发送ack=seq+1（服务器随机码应答）</li>
<li>服务器确认ack后建立连接，完成三次握手<br>四次撒手</li>
<li></li>
</ul>
</blockquote>
<h3 id="react-native-渲染原理"><a href="#react-native-渲染原理" class="headerlink" title="react native 渲染原理"></a>react native 渲染原理</h3><blockquote>
<p>Write once, Run anywhere!<br>需要 UIKit 等框架，调用OC代码<br>以 JavaScript 的形式告诉 Objective-C 该执行什么代码</p>
</blockquote>
<h3 id="Vue原理"><a href="#Vue原理" class="headerlink" title="Vue原理"></a>Vue原理</h3><blockquote>
<p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个<strong>监听器Observer</strong>，用来监听所有属性。如果属性发上变化了，就需要告诉<strong>订阅者Watcher</strong>看是否需要更新。因为订阅者是有很多个，所以我们需要有一个<strong>消息订阅器Dep</strong>来专门收集这些订阅者，然后在<strong>监听器Observer</strong>和<strong>订阅者Watcher</strong>之间进行统一管理的。接着，我们还需要有一个指令<strong>解析器Compile</strong>，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个<strong>订阅者Watcher</strong>，并替换模板数据或者绑定相应的函数，此时当<strong>订阅者Watcher</strong>接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p>
</blockquote>
<ul>
<li>实现一个<strong>监听器Observer</strong>，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</li>
<li>实现一个<strong>订阅者Watcher</strong>，可以收到属性的变化通知并执行相应的函数，从而更新视图。</li>
<li>实现一个<strong>解析器Compile</strong>，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</li>
</ul>
<h3 id="前向代理和反向代理"><a href="#前向代理和反向代理" class="headerlink" title="前向代理和反向代理"></a>前向代理和反向代理</h3><blockquote>
<p><strong>前向代理：</strong>中间服务器M接收了客户端C的请求后，（有选择的）对请求进行简化或者其他处理，再向目标服务器S请求数据。</p>
<ul>
<li>C————-M————-S</li>
<li>翻墙，隐藏客户端，</li>
</ul>
</blockquote>
<blockquote>
<p><strong>反向代理：</strong>客户端C访问服务器S而言，好像A真的再访问S一样，其实真正的服务器是在S后面的M。</p>
<ul>
<li>C————-S————-M</li>
<li>负载均衡，加速访问静态内容（缓存），隐藏真实服务器</li>
</ul>
</blockquote>
<h3 id="mvc-mvvm-区别"><a href="#mvc-mvvm-区别" class="headerlink" title="mvc mvvm 区别"></a>mvc mvvm 区别</h3><ul>
<li>mvc: 界面上的每个变化都是一个事件，我只需要针对每个事件写一堆代码，来把用户的输入转换成model里的对象就行了，这堆代码可以叫controller</li>
<li>mvvn: 我给view里面的各种控件也定义一个对应的数据对象，这样，只要修改这个数据对象，view里面显示的内容就自动跟着刷新，而在view 里做了任何操作，这个数据对象也跟着自动更新，这样多美</li>
</ul>
<h3 id="mvvm优点"><a href="#mvvm优点" class="headerlink" title="mvvm优点"></a>mvvm优点</h3><ul>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModemvvmdi计人员可以专注于UI(View)的设计</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote>
<p>如何判断回收内容: 一个对象为活对象当且仅当它被一个根对象或另一个活对象指向<br>如何识别指针和数据: 标记清除算法（在每个字末位预留一位来标记这个字段是指针还是数）<a href="https://segmentfault.com/a/1190000000440270" target="_blank" rel="noopener">更多详情</a></p>
</blockquote>

    
  </div>
</article>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/07/22/rxjs-in-use/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/09/13/frequently-used/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'leonzhang1108';
    
    var disqus_url = 'http://6rina.cc/2017/09/07/fe-interview/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//leonzhang1108.disqus.com/count.js" async></script>



    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
