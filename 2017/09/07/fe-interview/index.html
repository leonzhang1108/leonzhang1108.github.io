<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>前端面试升级 | Leonzhang&#39;s blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="All Hail JLA" />
  

  <meta name="description" content="AMD &amp;amp; CMD// CMD// 延迟执行// 代码运行时不知道依赖，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能define(function(require, exports, module) &amp;#123;     var a = require(&apos;./a&apos;)     a.">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试升级">
<meta property="og:url" content="http://leonzh.cc/2017/09/07/fe-interview/index.html">
<meta property="og:site_name" content="Leonzhang&#39;s blog">
<meta property="og:description" content="AMD &amp;amp; CMD// CMD// 延迟执行// 代码运行时不知道依赖，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能define(function(require, exports, module) &amp;#123;     var a = require(&apos;./a&apos;)     a.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-09-08T12:34:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试升级">
<meta name="twitter:description" content="AMD &amp;amp; CMD// CMD// 延迟执行// 代码运行时不知道依赖，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能define(function(require, exports, module) &amp;#123;     var a = require(&apos;./a&apos;)     a.">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>




<div class="content content-post CENTER">
   <article id="post-fe-interview" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">前端面试升级</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.09.07</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Leon Zhang</span>
        </span>
      

      


      
        <span>
          <i class="icon-comment"></i>
          <a href="http://leonzh.cc/2017/09/07/fe-interview/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h3 id="AMD-amp-CMD"><a href="#AMD-amp-CMD" class="headerlink" title="AMD &amp; CMD"></a>AMD &amp; CMD</h3><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CMD</span></div><div class="line"><span class="comment">// 延迟执行</span></div><div class="line"><span class="comment">// 代码运行时不知道依赖，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>) </div><div class="line">    a.doSomething() </div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) </div><div class="line">    b.doSomething() </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// AMD</span></div><div class="line"><span class="comment">// 提前执行</span></div><div class="line"><span class="comment">// 在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块</span></div><div class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; </div><div class="line">    a.doSomething() </div><div class="line">    b.doSomething() </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 对于软依赖的处理，推荐依赖前置+回调函数的实现形式</span></div><div class="line"><span class="keyword">if</span>(status)&#123; </div><div class="line">    <span class="keyword">async</span>([<span class="string">'a'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123; </div><div class="line">        a.doSomething() </div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>-</th>
<th style="text-align:center">CMD(seajs)</th>
<th style="text-align:right">AMD(requirejs)</th>
</tr>
</thead>
<tbody>
<tr>
<td>对于依赖的模块</td>
<td style="text-align:center">延迟执行(异步require)</td>
<td style="text-align:right">提前执行(同步require)</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">依赖就近</td>
<td style="text-align:right">依赖前置 </td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">API 严格区分，推崇职责单一</td>
<td style="text-align:right">API 默认是一个当多个用</td>
</tr>
</tbody>
</table>
<h3 id="react-virtual-dom"><a href="#react-virtual-dom" class="headerlink" title="react virtual dom"></a>react virtual dom</h3><blockquote>
<p>在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何 进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前 整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟 DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化，而如果通过手动控 制，这种逻辑通常是极其复杂的。尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是 Diff部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要 关心在任意一个数据状态下，整个界面是如何Render的。</p>
</blockquote>
<h3 id="react-v-dom-渲染流程"><a href="#react-v-dom-渲染流程" class="headerlink" title="react v-dom 渲染流程"></a>react v-dom 渲染流程</h3><ul>
<li>Javascript DOM模型树（VTree），类似文档节点树（DOM）</li>
<li>DOM模型树转节点树方法（VTree -&gt; DOM）</li>
<li>两个DOM模型树的差异算法（diff(VTree, VTree) -&gt; PatchObject）</li>
<li>根据差异操作节点方法（patch(DOMNode, PatchObject) -&gt; DOMNode）</li>
</ul>
<h3 id="常见开发漏洞"><a href="#常见开发漏洞" class="headerlink" title="常见开发漏洞"></a>常见开发漏洞</h3><ul>
<li>xss(cross site scripting): 攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</li>
<li>sql注入: 用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。</li>
</ul>
<!-- ### BFC, IFC, GFC 和 FFC
> aka Block Formatting Contexts, Inline FC, GridLayout FC, Flex FC. 
> BFC: 块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素
> * 如何产生BFC: float不为none, overflow不为visible, position不为static或relative, display为table-cell, table-caption, inline-block -->
<h3 id="DNS原理"><a href="#DNS原理" class="headerlink" title="DNS原理"></a>DNS原理</h3><ul>
<li>发送域名解析请求，发送本地域名服务器</li>
<li>本地域名服务器若有本地缓存，返回结果，没有缓存，请求上级域名服务器</li>
<li>以此类推，直到找到，返回域名，并缓存在路径中路过的域名服务器中</li>
</ul>
<h3 id="html5语义化优势"><a href="#html5语义化优势" class="headerlink" title="html5语义化优势"></a>html5语义化优势</h3><ul>
<li>无css情况下也能呈现结构</li>
<li>title、alt用于解释名词或解释图片信息、label标签的活用，增加用户体验</li>
<li>利于SEO优化</li>
<li>方便其它设备解析</li>
<li>便于维护</li>
</ul>
<h3 id="哪些语义化标签"><a href="#哪些语义化标签" class="headerlink" title="哪些语义化标签"></a>哪些语义化标签</h3><blockquote>
<p>header, footer, article, nav, aside, section…</p>
</blockquote>
<h3 id="jsonp，getJSON-getScript"><a href="#jsonp，getJSON-getScript" class="headerlink" title="jsonp，getJSON(),getScript()"></a>jsonp，getJSON(),getScript()</h3><blockquote>
<p>Jsonp: 解决跨域问题。允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据<br>getScript(): </p>
<ul>
<li>客户端: jQuery.getScript(url, () =&gt; console.log(result))</li>
<li>服务端: var result = { name: ‘leonzhang’ }</li>
</ul>
</blockquote>
<h3 id="定义JS类"><a href="#定义JS类" class="headerlink" title="定义JS类"></a>定义JS类</h3><blockquote>
<p>构造函数法：js<strong>类</strong>的定义方法和<strong>函数</strong>的定义方法一样，所以<em>定义</em>了<strong>构造函数</strong>就<em>定义</em>了<strong>类</strong>，<strong>构造函数</strong>内的<em>方法和属性</em>也就是<strong>类</strong>中的<em>方法和属性</em></p>
</blockquote>
<h3 id="JS继承（6种）"><a href="#JS继承（6种）" class="headerlink" title="JS继承（6种）"></a>JS继承（6种）</h3><blockquote>
<p><strong>简单原型链继承</strong></p>
<ul>
<li>优点: 简单</li>
<li>缺点: 1. 来自原型对象的引用属性是所有实例共享的 2. 创建子类实例时，无法向父类构造函数传参<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.job = <span class="string">'super hero'</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Robin</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Robin.prototype = <span class="keyword">new</span> Batman()</div><div class="line"><span class="keyword">var</span> robin = <span class="keyword">new</span> Robin()</div><div class="line"><span class="built_in">console</span>.log(robin.job)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>构造函数</strong> </p>
<ul>
<li>优点: 修复简单原型链的缺点</li>
<li>缺点: 无法实现函数复用，内存爆炸<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = val</div><div class="line">    <span class="keyword">this</span>.job = <span class="string">'super hero'</span></div><div class="line">    <span class="keyword">this</span>.roar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'ironman sucks'</span>) &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Robin</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Batman.call(<span class="keyword">this</span>, val)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> robin = <span class="keyword">new</span> Robin()</div><div class="line"><span class="built_in">console</span>.log(robin.roar())</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>组合继承(最常用)</strong></p>
<ul>
<li>优点: 不存在共享，可传参，函数可复用</li>
<li>缺点: 子类原型上有一份多余的父类实例属性<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = val</div><div class="line">    <span class="keyword">this</span>.job = <span class="string">'super hero'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//  在此处声明函数</span></div><div class="line">Batman.prototype.roar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'ironman sucks'</span>) &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Robin</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Batman.call(<span class="keyword">this</span>, val)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> robin = <span class="keyword">new</span> Robin()</div><div class="line">robin.roar()</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>寄生组合继承（最佳）</strong></p>
<ul>
<li>优点: 完美</li>
<li>缺点: 麻烦<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>)</span>&#123;   <span class="comment">// 生孩子函数 beget：龙beget龙，凤beget凤。</span></div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = obj</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">    <span class="comment">// 只在此处声明基本属性和引用属性</span></div><div class="line">    <span class="keyword">this</span>.val = val</div><div class="line">&#125;</div><div class="line"><span class="comment">//  在此处声明函数</span></div><div class="line">Batman.prototype.roar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'ironman sucks'</span>) &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Robin</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Batman.call(<span class="keyword">this</span>, val)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 下三行重点</span></div><div class="line"><span class="keyword">var</span> proto = beget(Batman.prototype)</div><div class="line">proto.constructor = Robin</div><div class="line">Robin.prototype = proto</div><div class="line"><span class="keyword">var</span> robin = <span class="keyword">new</span> Robin()</div><div class="line">robin.roar()</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>原型式</strong></p>
<ul>
<li>优点: 从已有对象衍生新对象，不需要创建自定义类型</li>
<li>缺点: 无法实现代码复用，原型引用属性会被所有实例共享<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>)</span>&#123;   </div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = obj</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = val</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> batman = <span class="keyword">new</span> Batman()</div><div class="line"><span class="keyword">var</span> robin = beget(batman)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>寄生式</strong></p>
<ul>
<li>优点: 不需要创建自定义类型</li>
<li>缺点: 无法实现函数复用<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>)</span>&#123;   </div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = obj</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batman</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = val</div><div class="line">    <span class="keyword">this</span>.roar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'ironman sucks'</span>) &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSubObject</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="comment">// 创建新对象</span></div><div class="line">    <span class="keyword">var</span> clone = beget(obj) <span class="comment">// 核心</span></div><div class="line">    <span class="comment">// 增强</span></div><div class="line">    clone.attr1 = <span class="number">1</span></div><div class="line">    clone.attr2 = <span class="number">2</span></div><div class="line">    <span class="comment">//clone.attr3...</span></div><div class="line">    <span class="keyword">return</span> clone</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> robin = getSubObject(<span class="keyword">new</span> Batman())</div><div class="line">robin.roar()</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">returnFun</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> add(a + b)</div><div class="line">    &#125;</div><div class="line">    returnFun.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> a</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> returnFun</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString()) <span class="comment">//6</span></div></pre></td></tr></table></figure>
<h3 id="三次握手-四次撒手"><a href="#三次握手-四次撒手" class="headerlink" title="三次握手 四次撒手"></a>三次握手 四次撒手</h3><blockquote>
<p>三次握手</p>
<ul>
<li>客户端发送SYN=1，且发送随机seq</li>
<li>服务器受到SYN=1，返回一个ACK=1（表示确认），并同返回一个请求连接SYN=1，然后返回一个ack=seq+1（客户端随机码应答），且自己也返回一个seq（随机码）</li>
<li>客户端收到服务器的ack后验证，向服务器确认包发送ack=seq+1（服务器随机码应答）</li>
<li>服务器确认ack后建立连接，完成三次握手<br>四次撒手</li>
<li></li>
</ul>
</blockquote>
<h3 id="react-native-渲染原理"><a href="#react-native-渲染原理" class="headerlink" title="react native 渲染原理"></a>react native 渲染原理</h3><blockquote>
<p>Write once, Run anywhere!<br>需要 UIKit 等框架，调用OC代码<br>以 JavaScript 的形式告诉 Objective-C 该执行什么代码</p>
</blockquote>
<h3 id="mvc-mvvm-区别"><a href="#mvc-mvvm-区别" class="headerlink" title="mvc mvvm 区别"></a>mvc mvvm 区别</h3><ul>
<li>mvc: 界面上的每个变化都是一个事件，我只需要针对每个事件写一堆代码，来把用户的输入转换成model里的对象就行了，这堆代码可以叫controller</li>
<li>mvvn: 我给view里面的各种控件也定义一个对应的数据对象，这样，只要修改这个数据对象，view里面显示的内容就自动跟着刷新，而在view 里做了任何操作，这个数据对象也跟着自动更新，这样多美</li>
</ul>
<h3 id="mvvm优点"><a href="#mvvm优点" class="headerlink" title="mvvm优点"></a>mvvm优点</h3><ul>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModemvvmdi计人员可以专注于UI(View)的设计</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote>
<p>如何判断回收内容: 一个对象为活对象当且仅当它被一个根对象或另一个活对象指向<br>如何识别指针和数据: 标记清除算法（在每个字末位预留一位来标记这个字段是指针还是数）<a href="https://segmentfault.com/a/1190000000440270" target="_blank" rel="external">更多详情</a></p>
</blockquote>

    
  </div>
</article>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/07/22/rxjs-in-use/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="hide pull-right" href="/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'leonzhang1108';
    
    var disqus_url = 'http://leonzh.cc/2017/09/07/fe-interview/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//leonzhang1108.disqus.com/count.js" async></script>



    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
