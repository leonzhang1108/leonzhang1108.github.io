<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Rxjs学习 | Leonzhang&#39;s blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="All Hail JLA" />
  

  <meta name="description" content="Rxjs 事件产生逻辑和处理逻辑分离 事件处理逻辑被数据结构化 自由组合 方便修改扩展  设计模式观察者模式好处 广播通知所有已订阅用户 目标对象与观察者动态关联 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用  class Product &amp;#123;    constructor() &amp;#123;        this.price = 0;        this.actions =">
<meta property="og:type" content="article">
<meta property="og:title" content="Rxjs学习">
<meta property="og:url" content="http://6rina.cc/2017/07/22/rxjs/index.html">
<meta property="og:site_name" content="Leonzhang&#39;s blog">
<meta property="og:description" content="Rxjs 事件产生逻辑和处理逻辑分离 事件处理逻辑被数据结构化 自由组合 方便修改扩展  设计模式观察者模式好处 广播通知所有已订阅用户 目标对象与观察者动态关联 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用  class Product &amp;#123;    constructor() &amp;#123;        this.price = 0;        this.actions =">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-07-22T16:08:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rxjs学习">
<meta name="twitter:description" content="Rxjs 事件产生逻辑和处理逻辑分离 事件处理逻辑被数据结构化 自由组合 方便修改扩展  设计模式观察者模式好处 广播通知所有已订阅用户 目标对象与观察者动态关联 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用  class Product &amp;#123;    constructor() &amp;#123;        this.price = 0;        this.actions =">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>




<div class="content content-post CENTER">
   <article id="post-rxjs" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Rxjs学习</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.07.22</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Leon Zhang</span>
        </span>
      

      


      
        <span>
          <i class="icon-comment"></i>
          <a href="http://leonzh.cc/2017/07/22/rxjs/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="Rxjs"><a href="#Rxjs" class="headerlink" title="Rxjs"></a>Rxjs</h1><ul>
<li>事件产生逻辑和处理逻辑分离</li>
<li>事件处理逻辑被数据结构化 自由组合 方便修改扩展</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>广播通知所有已订阅用户</li>
<li>目标对象与观察者动态关联</li>
<li>目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.price = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.actions = [];</span><br><span class="line">    &#125;</span><br><span class="line">    setBasePrice(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.price = val;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    register(observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.actions.push(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister(observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.actions.remove.filter(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> el !== observer;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAll() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.actions.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">            el.update(<span class="keyword">this</span>);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fees</span> </span>&#123;</span><br><span class="line">    update(product) &#123;</span><br><span class="line">        product.price = product.price * <span class="number">1.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proft</span> </span>&#123;</span><br><span class="line">    update(product) &#123;</span><br><span class="line">        product.price = product.price * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> product = <span class="keyword">new</span> Product();</span><br><span class="line">product.register(<span class="keyword">new</span> fees());</span><br><span class="line">product.register(<span class="keyword">new</span> proft());</span><br><span class="line">product.setBasePrice(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h3 id="迭代器模式：不管要遍历的数据结构是什么，用同样的方式操作它们"><a href="#迭代器模式：不管要遍历的数据结构是什么，用同样的方式操作它们" class="headerlink" title="迭代器模式：不管要遍历的数据结构是什么，用同样的方式操作它们"></a>迭代器模式：不管要遍历的数据结构是什么，用同样的方式操作它们</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(el) &#123;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.elements = el;</span><br><span class="line">    &#125;</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.elements[<span class="keyword">this</span>.index++];</span><br><span class="line">    &#125;</span><br><span class="line">    hasNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.elements.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> Iterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">numbers.next()</span><br><span class="line">numbers.next()</span><br><span class="line">numbers.next()</span><br><span class="line">numbers.hasNext()</span><br></pre></td></tr></table></figure>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><strong>Observable(可观察对象)</strong>：一个可调用的未来值或事件的集合</li>
<li><strong>Observer(观察者)</strong>：一个回调函数的集合，它知道如何去监听由 Observable 提供的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line">  x =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Subscription (订阅)</strong>：可清理资源的对象，表示 Observable 的执行，主要用于取消 Observable 的执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> subscription = observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br><span class="line"><span class="comment">// 稍后：</span></span><br><span class="line"><span class="comment">// 这会取消正在进行中的 Observable 执行</span></span><br><span class="line"><span class="comment">// Observable 执行是通过使用观察者调用 subscribe 方法启动的</span></span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Subject (主体)</strong>：相当于 EventEmitter，并且是将值或事件<strong>多路推送</strong>给多个 Observer 的唯一方式。每个 Subject 都是 Observable</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observable1 = Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line">subject.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>+x))</span><br><span class="line">subject.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>+x))</span><br><span class="line"><span class="keyword">var</span> subscription = observable1.subscribe(subject)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">var</span> multicasted = source.multicast(subject);</span><br><span class="line"><span class="comment">// 在底层使用了 `subject.subscribe(&#123;...&#125;)`:</span></span><br><span class="line">multicasted.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">multicasted.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在底层使用了 `source.subscribe(subject)`:</span></span><br><span class="line">multicasted.connect()</span><br></pre></td></tr></table></figure>
<ul>
<li>请考虑以下示例，下面的列表概述了 Subscriptions 发生的经过：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个观察者订阅了多播 Observable</span><br><span class="line">多播 Observable 已连接</span><br><span class="line">next 值 0 发送给第一个观察者</span><br><span class="line">第二个观察者订阅了多播 Observable</span><br><span class="line">next 值 1 发送给第一个观察者</span><br><span class="line">next 值 1 发送给第二个观察者</span><br><span class="line">第一个观察者取消了多播 Observable 的订阅</span><br><span class="line">next 值 2 发送给第二个观察者</span><br><span class="line">第二个观察者取消了多播 Observable 的订阅</span><br><span class="line">多播 Observable 的连接已中断(底层进行的操作是取消订阅)</span><br></pre></td></tr></table></figure>
<ul>
<li>要实现这点，需要显示地调用 connect()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Observable.interval(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">var</span> multicasted = source.multicast(subject);</span><br><span class="line"><span class="keyword">var</span> subscription1, subscription2, subscriptionConnect</span><br><span class="line">subscription1 = multicasted.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这里我们应该调用 `connect()`，因为 `multicasted` 的第一个</span></span><br><span class="line"><span class="comment">// 订阅者关心消费值</span></span><br><span class="line">subscriptionConnect = multicasted.connect()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  subscription2 = multicasted.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">600</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  subscription1.unsubscribe();</span><br><span class="line">&#125;, <span class="number">1200</span>);</span><br><span class="line"><span class="comment">// 这里我们应该取消共享的 Observable 执行的订阅，</span></span><br><span class="line"><span class="comment">// 因为此后 `multicasted` 将不再有订阅者</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  subscription2.unsubscribe();</span><br><span class="line">  subscriptionConnect.unsubscribe(); <span class="comment">// 用于共享的 Observable 执行</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>refCount 的作用是，当有第一个订阅者时，多播 Observable 会自动地启动执行，而当最后一个订阅者离开时，多播 Observable 会自动地停止执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Observable.interval(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">var</span> refCounted = source.multicast(subject).refCount();</span><br><span class="line"><span class="keyword">var</span> subscription1, subscription2, subscriptionConnect;</span><br><span class="line"><span class="comment">// 这里其实调用了 `connect()`，</span></span><br><span class="line"><span class="comment">// 因为 `refCounted` 有了第一个订阅者</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'observerA subscribed'</span>);</span><br><span class="line">subscription1 = refCounted.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'observerB subscribed'</span>);</span><br><span class="line">  subscription2 = refCounted.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">600</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'observerA unsubscribed'</span>);</span><br><span class="line">  subscription1.unsubscribe();</span><br><span class="line">&#125;, <span class="number">1200</span>);</span><br><span class="line"><span class="comment">// 这里共享的 Observable 执行会停止，</span></span><br><span class="line"><span class="comment">// 因为此后 `refCounted` 将不再有订阅者</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'observerB unsubscribed'</span>);</span><br><span class="line">  subscription2.unsubscribe();</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>BehaviorSubject(当前值)</strong>：它保存了发送给消费者的<strong>最新值</strong>。并且当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到“当前值”。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> BehaviorSubject(<span class="number">0</span>); <span class="comment">// 0是初始值</span></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.next(<span class="number">1</span>);</span><br><span class="line">subject.next(<span class="number">2</span>); <span class="comment">// 最新值 新的订阅时 接受当前值</span></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.next(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ReplaySubject(重播？？)</strong>：类似于 BehaviorSubject，它可以发送旧值给新的订阅者，但它还可以记录 Observable 执行的一部分。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> ReplaySubject(<span class="number">3</span>); <span class="comment">// 为新的订阅者缓冲3个值</span></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.next(<span class="number">1</span>);</span><br><span class="line">subject.next(<span class="number">2</span>);</span><br><span class="line">subject.next(<span class="number">3</span>);</span><br><span class="line">subject.next(<span class="number">4</span>);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.next(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AsyncSubject(异步主体)</strong>：只有当 Observable 执行完成时(执行 complete())，它才会将执行的<strong>最后一个</strong>值发送给观察者</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> AsyncSubject();</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.next(<span class="number">1</span>);</span><br><span class="line">subject.next(<span class="number">2</span>);</span><br><span class="line">subject.next(<span class="number">3</span>);</span><br><span class="line">subject.next(<span class="number">4</span>);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.next(<span class="number">5</span>);</span><br><span class="line">subject.complete();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Operators (操作符)</strong>：map、filter、concat、flatMap 等。不改变已存在的Observable，返回新的Observable，新Observable 的subscription逻辑基于第一个Observable</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyByTen</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> output = Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    input.subscribe(&#123;</span><br><span class="line">      next: <span class="function">(<span class="params">v</span>) =&gt;</span> observer.next(<span class="number">10</span> * v), <span class="comment">// next触发执行</span></span><br><span class="line">      error: <span class="function">(<span class="params">err</span>) =&gt;</span> observer.error(err),</span><br><span class="line">      complete: <span class="function"><span class="params">()</span> =&gt;</span> observer.complete()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> input = Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">var</span> output = multiplyByTen(input);</span><br><span class="line">input(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br><span class="line">output.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实例操作符</strong>: Observable 实例上的方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.prototype.multiplyByTen = <span class="function"><span class="keyword">function</span> <span class="title">multiplyByTen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> input = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    input.subscribe(&#123;</span><br><span class="line">      next: <span class="function">(<span class="params">v</span>) =&gt;</span> observer.next(<span class="number">10</span> * v),</span><br><span class="line">      error: <span class="function">(<span class="params">err</span>) =&gt;</span> observer.error(err),</span><br><span class="line">      complete: <span class="function"><span class="params">()</span> =&gt;</span> observer.complete()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> observable = Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).multiplyByTen()</span><br><span class="line">observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>静态操作符</strong>：只接收非Observable参数，创建一个新的Observable<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Observable.interval(<span class="number">1000</span> <span class="comment">/* 毫秒数 */</span>)</span><br><span class="line">merged.subscribe(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>组合操作符也是静态的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observable1 = Observable.interval(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">var</span> observable2 = Observable.interval(<span class="number">400</span>)</span><br><span class="line"><span class="keyword">var</span> merged = Observable.merge(observable1, observable2)</span><br><span class="line">merged.subscribe(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>Schedulers (调度器)</strong>：调度器控制着何时启动 subscription 和何时发送通知</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Observable.create(<span class="function">(<span class="params">proxyObserver</span>) =&gt;</span> &#123;</span><br><span class="line">  proxyObserver.next(<span class="number">1</span>);</span><br><span class="line">  proxyObserver.next(<span class="number">2</span>);</span><br><span class="line">  proxyObserver.next(<span class="number">3</span>);</span><br><span class="line">  proxyObserver.complete();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//proxyObserver是在 observeOn(Scheduler.async) 中创建的</span></span><br><span class="line">.observeOn(Scheduler.async);  <span class="comment">// 异步</span></span><br><span class="line"><span class="keyword">var</span> finalObserver = &#123;</span><br><span class="line">  next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'got value '</span> + x),</span><br><span class="line">  error: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'something wrong occurred: '</span> + err),</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'done'</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'just before subscribe'</span>);</span><br><span class="line">observable.subscribe(finalObserver);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'just after subscribe'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调度器类型</p>
<ul>
<li>Scheduler.queue：当前事件帧中的队列调度(蹦床调度器)。用于迭代操作。</li>
<li>Scheduler.asap：微任务的队列调度，它使用可用的最快速的传输机制。用于异步转换</li>
<li>Scheduler.async：使用 setInterval 的调度。用于基于时间的操作符。</li>
<li>null：不传递任何调度器的话，会以同步递归的方式发送通知。用于定时操作或尾递归操作。</li>
</ul>
</blockquote>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>func.call() 意思是 “同步地给我一个值”</li>
<li>observable.subscribe() 意思是 “给我任意数量的值，无论是同步还是异步”</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="create-创建操作符"><a href="#create-创建操作符" class="headerlink" title="create 创建操作符"></a>create 创建操作符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="string">'hi'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">observable.subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="do-通常用来加log"><a href="#do-通常用来加log" class="headerlink" title="do 通常用来加log"></a>do 通常用来加log</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">  .do(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`BEFORE MAP: <span class="subst">$&#123;val&#125;</span>`</span>))</span><br><span class="line">  .map(<span class="function"><span class="params">val</span> =&gt;</span> val + <span class="number">10</span>)</span><br><span class="line">  .do(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`AFTER MAP: <span class="subst">$&#123;val&#125;</span>`</span>))</span><br><span class="line">    .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="startWith-源序列之前添加额外的元素"><a href="#startWith-源序列之前添加额外的元素" class="headerlink" title="startWith 源序列之前添加额外的元素"></a>startWith 源序列之前添加额外的元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = Observable.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); </span><br><span class="line"><span class="keyword">const</span> target = source.startWith(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>); </span><br><span class="line">target.subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="buffer-自定义分组"><a href="#buffer-自定义分组" class="headerlink" title="buffer  自定义分组"></a>buffer  自定义分组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterval = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">const</span> bufferBy = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">myInterval.buffer(bufferBy) <span class="comment">// buffer参数为分组标志</span></span><br><span class="line">  .subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">' Buffered Values:'</span>, val))</span><br></pre></td></tr></table></figure>
<h3 id="bufferTime-根据时间标识分组"><a href="#bufferTime-根据时间标识分组" class="headerlink" title="bufferTime 根据时间标识分组"></a>bufferTime 根据时间标识分组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">  .bufferTime(<span class="number">3000</span>)</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="bufferCount-根据计数标识分组"><a href="#bufferCount-根据计数标识分组" class="headerlink" title="bufferCount 根据计数标识分组"></a>bufferCount 根据计数标识分组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">  .bufferCount(<span class="number">3</span>)</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="bufferToggle-分组开关"><a href="#bufferToggle-分组开关" class="headerlink" title="bufferToggle   分组开关"></a>bufferToggle   分组开关</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始等5秒</span></span><br><span class="line"><span class="comment">// 1秒后打印 然后跳去closingInterval</span></span><br><span class="line"><span class="comment">// 3秒后跳回</span></span><br><span class="line"><span class="keyword">const</span> sourceInterval = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">const</span> startInterval = Rx.Observable.interval(<span class="number">5000</span>)</span><br><span class="line"><span class="keyword">const</span> closingInterval = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Value <span class="subst">$&#123;val&#125;</span> emitted, starting buffer! Closing in 3s!`</span>)</span><br><span class="line">  <span class="keyword">return</span> Rx.Observable.interval(<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bufferToggleInterval = sourceInterval.bufferToggle(startInterval, closingInterval)</span><br><span class="line"><span class="keyword">const</span> subscribe = bufferToggleInterval.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Emitted Buffer:'</span>, val))</span><br></pre></td></tr></table></figure>
<h3 id="bufferWhen-基于时间分组"><a href="#bufferWhen-基于时间分组" class="headerlink" title="bufferWhen    基于时间分组"></a>bufferWhen    基于时间分组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oneSecondInterval = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> twoSecondInterval = <span class="function"><span class="params">()</span> =&gt;</span> Rx.Observable.interval(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">const</span> bufferWhenExample = oneSecondInterval.bufferWhen(twoSecondInterval)</span><br><span class="line"><span class="keyword">const</span> subscribe = bufferWhenExample.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Emitted Buffer: '</span>, val));</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><h3 id="switchMap-对Observable进行转换，并刷新当前Observable-同flatMapLatest"><a href="#switchMap-对Observable进行转换，并刷新当前Observable-同flatMapLatest" class="headerlink" title="switchMap  对Observable进行转换，并刷新当前Observable (同flatMapLatest)"></a>switchMap  对Observable进行转换，并刷新当前Observable (同flatMapLatest)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次点击 重新计时</span></span><br><span class="line">Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .switchMap(<span class="function"><span class="params">()</span> =&gt;</span> Observable.interval(<span class="number">1000</span>))</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="switchMapTo-对Observable进行转换，并刷新当前Observable"><a href="#switchMapTo-对Observable进行转换，并刷新当前Observable" class="headerlink" title="switchMapTo  对Observable进行转换，并刷新当前Observable"></a>switchMapTo  对Observable进行转换，并刷新当前Observable</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .switchMapTo(Observable.interval(<span class="number">1000</span>))</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="window-产生新的Observable"><a href="#window-产生新的Observable" class="headerlink" title="window  产生新的Observable"></a>window  产生新的Observable</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clicks = Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">var</span> interval = Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> result = clicks.window(interval)</span><br><span class="line">  .map(<span class="function"><span class="params">win</span> =&gt;</span> win.take(<span class="number">2</span>)) <span class="comment">// each window has at most 2 emissions</span></span><br><span class="line">  .mergeAll(); <span class="comment">// flatten the Observable-of-Observables</span></span><br><span class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<h3 id="windowCount-根据数量间隔-产生不同的Observable"><a href="#windowCount-根据数量间隔-产生不同的Observable" class="headerlink" title="windowCount   根据数量间隔 产生不同的Observable"></a>windowCount   根据数量间隔 产生不同的Observable</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">    .windowCount(<span class="number">3</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">win</span> =&gt;</span> win.skip(<span class="number">1</span>))</span><br><span class="line">    .mergeAll()</span><br><span class="line">    .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="windowTime-根据时间间隔-产生不同的Observable"><a href="#windowTime-根据时间间隔-产生不同的Observable" class="headerlink" title="windowTime   根据时间间隔 产生不同的Observable"></a>windowTime   根据时间间隔 产生不同的Observable</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .windowTime(<span class="number">1000</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">win</span> =&gt;</span> win.take(<span class="number">2</span>)) <span class="comment">// each window has at most 2 emissions</span></span><br><span class="line">  .mergeAll() <span class="comment">// flatten the Observable-of-Observables</span></span><br><span class="line">  .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<h3 id="windowWhen-根据参数不同-产生不同的Observable"><a href="#windowWhen-根据参数不同-产生不同的Observable" class="headerlink" title="windowWhen   根据参数不同 产生不同的Observable"></a>windowWhen   根据参数不同 产生不同的Observable</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .windowWhen(<span class="function"><span class="params">()</span> =&gt;</span> Observable.interval(<span class="number">1000</span> + <span class="built_in">Math</span>.random() * <span class="number">4000</span>))</span><br><span class="line">  .map(<span class="function"><span class="params">win</span> =&gt;</span> win.take(<span class="number">2</span>))</span><br><span class="line">  .mergeAll()</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="interval-时间间隔"><a href="#interval-时间间隔" class="headerlink" title="interval 时间间隔"></a>interval 时间间隔</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval(<span class="number">1000</span>)</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>
<h3 id="timer-时间间隔-可控制开始时间"><a href="#timer-时间间隔-可控制开始时间" class="headerlink" title="timer 时间间隔 可控制开始时间"></a>timer 时间间隔 可控制开始时间</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.timer(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">  .take(<span class="number">5</span>)</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="debounce-防抖动，只有当另一个Observable发射值时，才取源Obervable的最新数据进行发射，其他数据取消发射"><a href="#debounce-防抖动，只有当另一个Observable发射值时，才取源Obervable的最新数据进行发射，其他数据取消发射" class="headerlink" title="debounce  防抖动，只有当另一个Observable发射值时，才取源Obervable的最新数据进行发射，其他数据取消发射"></a>debounce  防抖动，只有当另一个Observable发射值时，才取源Obervable的最新数据进行发射，其他数据取消发射</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval( <span class="number">1000</span> )</span><br><span class="line">  .debounce(<span class="function"><span class="params">()</span> =&gt;</span> Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>))</span><br><span class="line">  .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ));</span><br></pre></td></tr></table></figure>
<h3 id="debounceTime-防抖动，一段时间内，只取最新数据进行发射，其他数据取消发射"><a href="#debounceTime-防抖动，一段时间内，只取最新数据进行发射，其他数据取消发射" class="headerlink" title="debounceTime 防抖动，一段时间内，只取最新数据进行发射，其他数据取消发射"></a>debounceTime 防抖动，一段时间内，只取最新数据进行发射，其他数据取消发射</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">  .debounceTime( <span class="number">500</span> )</span><br><span class="line">  .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Leon'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出0,3,6,9,12.....</span></span><br><span class="line"><span class="comment">// 每次输出一个值，至少等待两秒后，才输出最新值</span></span><br><span class="line">Observable.interval( <span class="number">1000</span> )</span><br><span class="line">  .throttle( <span class="function"><span class="params">x</span> =&gt;</span> Observable.interval( <span class="number">2000</span> ))</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="throttleTime"><a href="#throttleTime" class="headerlink" title="throttleTime"></a>throttleTime</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval( <span class="number">1000</span> )</span><br><span class="line">  .throttleTime( <span class="number">2000</span> )</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="audit-当另一个Observable发射值前，源Observable的值会被忽略，当另一个Observable发射值时，才从源Observable发射一个最新值，然后重复上述过程"><a href="#audit-当另一个Observable发射值前，源Observable的值会被忽略，当另一个Observable发射值时，才从源Observable发射一个最新值，然后重复上述过程" class="headerlink" title="audit  当另一个Observable发射值前，源Observable的值会被忽略，当另一个Observable发射值时，才从源Observable发射一个最新值，然后重复上述过程"></a>audit  当另一个Observable发射值前，源Observable的值会被忽略，当另一个Observable发射值时，才从源Observable发射一个最新值，然后重复上述过程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval( <span class="number">1000</span> )</span><br><span class="line">  .audit(<span class="function"><span class="params">()</span> =&gt;</span> Observable.fromEvent( <span class="built_in">document</span>, <span class="string">'click'</span> ))</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="auditTime-在指定等待时间内，源Observable的值会被忽略，等待结束后，发射一个源Observable的最新值，然后重复上述过程。"><a href="#auditTime-在指定等待时间内，源Observable的值会被忽略，等待结束后，发射一个源Observable的最新值，然后重复上述过程。" class="headerlink" title="auditTime  在指定等待时间内，源Observable的值会被忽略，等待结束后，发射一个源Observable的最新值，然后重复上述过程。"></a>auditTime  在指定等待时间内，源Observable的值会被忽略，等待结束后，发射一个源Observable的最新值，然后重复上述过程。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval( <span class="number">1000</span> )</span><br><span class="line">  .auditTime( <span class="number">2000</span> )</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<ul>
<li>audit与throttle的区别是，第一个值的发射，是先等待再发射，而throttle是先发射第一个值，然后再等待</li>
</ul>
<h3 id="sample-当另一个Observable发射值时，才从源Observable数据集发射一个最新值"><a href="#sample-当另一个Observable发射值时，才从源Observable数据集发射一个最新值" class="headerlink" title="sample  当另一个Observable发射值时，才从源Observable数据集发射一个最新值"></a>sample  当另一个Observable发射值时，才从源Observable数据集发射一个最新值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval( <span class="number">1000</span> )</span><br><span class="line">  .sample( Observable.fromEvent( <span class="built_in">document</span>, <span class="string">'click'</span> ))</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="sampleTime-每隔一定的时间间隔，发射一个源Observable数据集的最新值。"><a href="#sampleTime-每隔一定的时间间隔，发射一个源Observable数据集的最新值。" class="headerlink" title="sampleTime  每隔一定的时间间隔，发射一个源Observable数据集的最新值。"></a>sampleTime  每隔一定的时间间隔，发射一个源Observable数据集的最新值。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval( <span class="number">1000</span> )</span><br><span class="line">  .sampleTime( <span class="number">2000</span> )</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="zip-使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射。（就触发一个）"><a href="#zip-使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射。（就触发一个）" class="headerlink" title="zip  使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射。（就触发一个）"></a>zip  使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射。（就触发一个）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> first = Observable.interval(<span class="number">2500</span>);</span><br><span class="line"><span class="keyword">const</span> second = Observable.interval(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">const</span> third = Observable.interval(<span class="number">1500</span>);</span><br><span class="line"><span class="keyword">const</span> fourth = Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> example = Observable.zip(</span><br><span class="line">  first.mapTo(<span class="string">'FIRST!'</span>),</span><br><span class="line">  second.mapTo(<span class="string">'SECOND!'</span>),</span><br><span class="line">  third.mapTo(<span class="string">'THIRD'</span>),</span><br><span class="line">  fourth.mapTo(<span class="string">'FOURTH'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> subscribe = example.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br></pre></td></tr></table></figure>
<h3 id="concat-多个序列拼成一个序列"><a href="#concat-多个序列拼成一个序列" class="headerlink" title="concat   多个序列拼成一个序列"></a>concat   多个序列拼成一个序列</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceOne = Observable.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> sourceTwo = Observable.of(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> example = sourceOne.concat(sourceTwo);</span><br><span class="line"><span class="comment">//const example = Observable.concat(sourceOne, sourceTwo);</span></span><br><span class="line"><span class="keyword">const</span> subscribe = example.subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="concatAll-若序列的元素也是序列，可用此合并（合并后依次执行）"><a href="#concatAll-若序列的元素也是序列，可用此合并（合并后依次执行）" class="headerlink" title="concatAll  若序列的元素也是序列，可用此合并（合并后依次执行）"></a>concatAll  若序列的元素也是序列，可用此合并（合并后依次执行）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obs1 = Observable.interval(<span class="number">1000</span>).take(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> obs2 = Observable.interval(<span class="number">500</span>).take(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> obs3 = Observable.interval(<span class="number">2000</span>).take(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> source = Observable.of(obs1, obs2, obs3);</span><br><span class="line"><span class="keyword">const</span> example = source.concatAll(); <span class="comment">// 依次执行</span></span><br><span class="line"><span class="keyword">const</span> subscribe = example.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br></pre></td></tr></table></figure>
<h3 id="concatMap-数据遍历映射为特定的Observable，并【依次】拼接"><a href="#concatMap-数据遍历映射为特定的Observable，并【依次】拼接" class="headerlink" title="concatMap  数据遍历映射为特定的Observable，并【依次】拼接"></a>concatMap  数据遍历映射为特定的Observable，并【依次】拼接</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">    .concatMapTo(Observable.interval(<span class="number">1000</span>).take(<span class="number">4</span>))</span><br><span class="line">    .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="exhaustMap-在有空时才进行数据映射"><a href="#exhaustMap-在有空时才进行数据映射" class="headerlink" title="exhaustMap  在有空时才进行数据映射"></a>exhaustMap  在有空时才进行数据映射</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>)</span><br><span class="line">    .exhaustMap(<span class="function">(<span class="params">ev</span>) =&gt;</span>Observable.interval(<span class="number">1000</span>).take(<span class="number">4</span>))</span><br><span class="line">    .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line"><span class="comment">// 每次点击，都会在4秒内，产生[0, 1, 2, 3]</span></span><br><span class="line"><span class="comment">// 在产生期间，新的点击不会再产生[0,1,2,3]</span></span><br></pre></td></tr></table></figure>
<h3 id="merge-将两个Observable发射的数据组合并成一个（有几个触发几个）"><a href="#merge-将两个Observable发射的数据组合并成一个（有几个触发几个）" class="headerlink" title="merge  将两个Observable发射的数据组合并成一个（有几个触发几个）"></a>merge  将两个Observable发射的数据组合并成一个（有几个触发几个）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> first = Observable.interval(<span class="number">2500</span>);</span><br><span class="line"><span class="keyword">const</span> second = Observable.interval(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">const</span> third = Observable.interval(<span class="number">1500</span>);</span><br><span class="line"><span class="keyword">const</span> fourth = Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> example = Observable.merge(</span><br><span class="line">  first.mapTo(<span class="string">'FIRST!'</span>),</span><br><span class="line">  second.mapTo(<span class="string">'SECOND!'</span>),</span><br><span class="line">  third.mapTo(<span class="string">'THIRD'</span>),</span><br><span class="line">  fourth.mapTo(<span class="string">'FOURTH'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> subscribe = example.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br></pre></td></tr></table></figure>
<h3 id="mergeAll-合并后同时执行"><a href="#mergeAll-合并后同时执行" class="headerlink" title="mergeAll  (合并后同时执行)"></a>mergeAll  (合并后同时执行)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obs1 = Observable.interval(<span class="number">1000</span>).take(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> obs2 = Observable.interval(<span class="number">500</span>).take(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> obs3 = Observable.interval(<span class="number">2000</span>).take(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> source = Observable.of(obs1, obs2, obs3);</span><br><span class="line"><span class="keyword">const</span> example = source.mergeAll(); <span class="comment">// 依次执行</span></span><br><span class="line"><span class="keyword">const</span> subscribe = example.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clicks = Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">const</span> higherOrder = clicks.map(<span class="function">(<span class="params">ev</span>) =&gt;</span> Observable.interval(<span class="number">1000</span>).take(<span class="number">5</span>));</span><br><span class="line"><span class="keyword">const</span> firstOrder = higherOrder.mergeAll(<span class="number">2</span>);</span><br><span class="line">firstOrder.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<h3 id="forkJoin-可以接受多个observable作为参数，然后并行执行所有的observable，但是最终的结果是每个observable的最后一个输出值"><a href="#forkJoin-可以接受多个observable作为参数，然后并行执行所有的observable，但是最终的结果是每个observable的最后一个输出值" class="headerlink" title="forkJoin  可以接受多个observable作为参数，然后并行执行所有的observable，但是最终的结果是每个observable的最后一个输出值"></a>forkJoin  可以接受多个observable作为参数，然后并行执行所有的observable，但是最终的结果是每个observable的最后一个输出值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = Observable.forkJoin(</span><br><span class="line">  Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">  Observable.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> subscription = source.subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="map-变换函数"><a href="#map-变换函数" class="headerlink" title="map  变换函数"></a>map  变换函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">   .map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">10</span>)</span><br><span class="line">   .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="pluck-获取元素对象制定属性"><a href="#pluck-获取元素对象制定属性" class="headerlink" title="pluck  获取元素对象制定属性"></a>pluck  获取元素对象制定属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of(&#123;<span class="attr">k</span>: <span class="number">1</span>, <span class="attr">v</span>: <span class="string">'leon'</span>&#125;, &#123;<span class="attr">k</span>: <span class="number">2</span>, <span class="attr">v</span>: <span class="string">'rina'</span>&#125;)</span><br><span class="line">  .pluck(<span class="string">'v'</span>)</span><br><span class="line">    .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="flatMap-平坦化映射"><a href="#flatMap-平坦化映射" class="headerlink" title="flatMap  平坦化映射"></a>flatMap  平坦化映射</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">  .flatMap(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.range(item, <span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="expand-递归的数据映射-expand会把上次产生的值传给自己，从而递归。"><a href="#expand-递归的数据映射-expand会把上次产生的值传给自己，从而递归。" class="headerlink" title="expand  递归的数据映射(expand会把上次产生的值传给自己，从而递归。)"></a>expand  递归的数据映射(expand会把上次产生的值传给自己，从而递归。)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">2</span>)</span><br><span class="line">  .expand(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.of(v + <span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .take(<span class="number">5</span>)</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="groupBy-根据指定条件对数据源进行分组"><a href="#groupBy-根据指定条件对数据源进行分组" class="headerlink" title="groupBy  根据指定条件对数据源进行分组"></a>groupBy  根据指定条件对数据源进行分组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iseven</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">"EVEN"</span> : <span class="string">"ODD"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> source = Observable.timer(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">Observable.timer(<span class="number">0</span>, <span class="number">1000</span>).groupBy(iseven)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.key === <span class="string">'EVEN'</span>) &#123; <span class="comment">// 根据key值选择group</span></span><br><span class="line">      x.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="pairwise-将每一个值变成数组-数组值为当前数字-下一项数字"><a href="#pairwise-将每一个值变成数组-数组值为当前数字-下一项数字" class="headerlink" title="pairwise  将每一个值变成数组 数组值为当前数字+下一项数字"></a>pairwise  将每一个值变成数组 数组值为当前数字+下一项数字</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval(<span class="number">1000</span>)</span><br><span class="line">  .pairwise()</span><br><span class="line">  .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="partition-把当前Observable分隔为两组Observable"><a href="#partition-把当前Observable分隔为两组Observable" class="headerlink" title="partition  把当前Observable分隔为两组Observable"></a>partition  把当前Observable分隔为两组Observable</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clicks = Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</span><br><span class="line"><span class="keyword">const</span> parts = clicks.partition(<span class="function"><span class="params">ev</span> =&gt;</span> ev.target.tagName === <span class="string">'DIV'</span>);</span><br><span class="line"><span class="keyword">const</span> clicksOnDivs = parts[<span class="number">0</span>]; <span class="comment">// 组1  符合情况的一组</span></span><br><span class="line"><span class="keyword">const</span> clicksElsewhere = parts[<span class="number">1</span>]; <span class="comment">// 组2  不符合情况的一组</span></span><br><span class="line">clicksOnDivs.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'DIV clicked: '</span>, x));</span><br><span class="line">clicksElsewhere.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Other clicked: '</span>, x));</span><br></pre></td></tr></table></figure>
<h3 id="combineAll-同mergeAll，返回数组"><a href="#combineAll-同mergeAll，返回数组" class="headerlink" title="combineAll    同mergeAll，返回数组"></a>combineAll    同mergeAll，返回数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line">   .take(<span class="number">1</span>)</span><br><span class="line">   .map(<span class="function"><span class="params">val</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>).map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="string">`Result is <span class="subst">$&#123;i&#125;</span>`</span>).take(<span class="number">5</span>))</span><br><span class="line">   .combineAll()</span><br><span class="line">   .subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="combineLatest-多个序列的最后一个元素，使用组合函数构成目标序列-的一个新元素"><a href="#combineLatest-多个序列的最后一个元素，使用组合函数构成目标序列-的一个新元素" class="headerlink" title="combineLatest  多个序列的最后一个元素，使用组合函数构成目标序列 的一个新元素"></a>combineLatest  多个序列的最后一个元素，使用组合函数构成目标序列 的一个新元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source1 = Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  .flatMap(<span class="function">(<span class="params">d, i</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> Observable.of(d).delay(i * <span class="number">1000</span>); </span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">var</span> source2 = Observable.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">  .flatMap(<span class="function">(<span class="params">d, i</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> Observable.of(d).delay(i * <span class="number">1500</span>); </span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">var</span> cf = <span class="function"><span class="keyword">function</span> (<span class="params">d1, d2</span>) </span>&#123; <span class="keyword">return</span> d1 + <span class="string">"-"</span> + d2; &#125;;</span><br><span class="line"><span class="keyword">var</span> target = source1.combineLatest(source2, cf);</span><br><span class="line">target.subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="race-取最快的"><a href="#race-取最快的" class="headerlink" title="race  取最快的"></a>race  取最快的</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> example = Rx.Observable.race(</span><br><span class="line">  Rx.Observable.interval(<span class="number">1500</span>),</span><br><span class="line">  Rx.Observable.interval(<span class="number">1000</span>).mapTo(<span class="string">'1s won!'</span>),</span><br><span class="line">  Rx.Observable.interval(<span class="number">2000</span>),</span><br><span class="line">  Rx.Observable.interval(<span class="number">2500</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> subscribe = example.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val));</span><br></pre></td></tr></table></figure>
<h3 id="withLatestFrom-仅在源序列输出元素时，-触发生成目标序列中的新元素"><a href="#withLatestFrom-仅在源序列输出元素时，-触发生成目标序列中的新元素" class="headerlink" title="withLatestFrom  仅在源序列输出元素时， 触发生成目标序列中的新元素"></a>withLatestFrom  仅在源序列输出元素时， 触发生成目标序列中的新元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source1 = Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  .flatMap(<span class="function">(<span class="params">d, i</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> Observable.of(d).delay(i * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">var</span> source2 = Observable.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">  .flatMap(<span class="function"><span class="keyword">function</span> (<span class="params">d, i</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> Observable.of(d).delay(i * <span class="number">1500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">var</span> cf = <span class="function">(<span class="params">d1, d2</span>) =&gt;</span> &#123; <span class="keyword">return</span> d1 + <span class="string">"-"</span> + d2; &#125;</span><br><span class="line"><span class="keyword">var</span> target = source1.withLatestFrom(source2, cf)</span><br><span class="line">target.subscribe(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<h3 id="take-比如take-3-表示取3个事件"><a href="#take-比如take-3-表示取3个事件" class="headerlink" title="take 比如take(3) 表示取3个事件"></a>take 比如take(3) 表示取3个事件</h3><h3 id="takeLast-比如takeLast-3-表示拿倒数三个"><a href="#takeLast-比如takeLast-3-表示拿倒数三个" class="headerlink" title="takeLast  比如takeLast(3)表示拿倒数三个"></a>takeLast  比如takeLast(3)表示拿倒数三个</h3><h3 id="takeUtil-从源Observable数据集的第一项开始进行发射，直到另一个Observable开始发射第一个值时，源Observable停止发射值"><a href="#takeUtil-从源Observable数据集的第一项开始进行发射，直到另一个Observable开始发射第一个值时，源Observable停止发射值" class="headerlink" title="takeUtil   从源Observable数据集的第一项开始进行发射，直到另一个Observable开始发射第一个值时，源Observable停止发射值"></a>takeUtil   从源Observable数据集的第一项开始进行发射，直到另一个Observable开始发射第一个值时，源Observable停止发射值</h3><h3 id="takeWhile-从源Observable数据集的第一个数据项开始发射值，直到遇到符合条件的第一个数据项后，停止源Observable数据集的发射"><a href="#takeWhile-从源Observable数据集的第一个数据项开始发射值，直到遇到符合条件的第一个数据项后，停止源Observable数据集的发射" class="headerlink" title="takeWhile   从源Observable数据集的第一个数据项开始发射值，直到遇到符合条件的第一个数据项后，停止源Observable数据集的发射"></a>takeWhile   从源Observable数据集的第一个数据项开始发射值，直到遇到符合条件的第一个数据项后，停止源Observable数据集的发射</h3><h3 id="first-取事件流第一个事件"><a href="#first-取事件流第一个事件" class="headerlink" title="first 取事件流第一个事件"></a>first 取事件流第一个事件</h3><h3 id="last-取事件流最后一个事件"><a href="#last-取事件流最后一个事件" class="headerlink" title="last 取事件流最后一个事件"></a>last 取事件流最后一个事件</h3><h3 id="filter-过滤器"><a href="#filter-过滤器" class="headerlink" title="filter 过滤器"></a>filter 过滤器</h3><h3 id="ignoreElement-忽略所有值"><a href="#ignoreElement-忽略所有值" class="headerlink" title="ignoreElement 忽略所有值"></a>ignoreElement 忽略所有值</h3><h3 id="single-若源Observable数据集只有一个数据项，则输出该项。若多于一个数据项，则报错"><a href="#single-若源Observable数据集只有一个数据项，则输出该项。若多于一个数据项，则报错" class="headerlink" title="single  若源Observable数据集只有一个数据项，则输出该项。若多于一个数据项，则报错"></a>single  若源Observable数据集只有一个数据项，则输出该项。若多于一个数据项，则报错</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of( <span class="number">1</span> )</span><br><span class="line">  .single( )</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="skip-跳过源Observable数据集的n个数据，然后才发射值。"><a href="#skip-跳过源Observable数据集的n个数据，然后才发射值。" class="headerlink" title="skip  跳过源Observable数据集的n个数据，然后才发射值。"></a>skip  跳过源Observable数据集的n个数据，然后才发射值。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">  .skip( <span class="number">2</span> )</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="skipUntil-忽略源Observable开头的一系列值，直到当另一个Observable开始发射值，才会从源Observable开始发射值"><a href="#skipUntil-忽略源Observable开头的一系列值，直到当另一个Observable开始发射值，才会从源Observable开始发射值" class="headerlink" title="skipUntil  忽略源Observable开头的一系列值，直到当另一个Observable开始发射值，才会从源Observable开始发射值"></a>skipUntil  忽略源Observable开头的一系列值，直到当另一个Observable开始发射值，才会从源Observable开始发射值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.interval( <span class="number">1000</span> )</span><br><span class="line">  .skipUntil( Observable.of( <span class="number">1</span> ).delay( <span class="number">3000</span> ))</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="skipWhile-忽略源Observable开头的一系列值，直到有一项符合条件，才开始从源Observable的该值开始，开始发射值。"><a href="#skipWhile-忽略源Observable开头的一系列值，直到有一项符合条件，才开始从源Observable的该值开始，开始发射值。" class="headerlink" title="skipWhile  忽略源Observable开头的一系列值，直到有一项符合条件，才开始从源Observable的该值开始，开始发射值。"></a>skipWhile  忽略源Observable开头的一系列值，直到有一项符合条件，才开始从源Observable的该值开始，开始发射值。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">  .skipWhile( <span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">4</span> )</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="scan-累加"><a href="#scan-累加" class="headerlink" title="scan 累加"></a>scan 累加</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">const</span> example = subject.scan(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, acc, curr), &#123;&#125;);  <span class="comment">//  scan第二个参数 初始值</span></span><br><span class="line"><span class="keyword">const</span> subscribe = example.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Accumulated object:'</span>, val));</span><br><span class="line">subject.next(&#123; <span class="attr">name</span>: <span class="string">'Leon'</span> &#125;); </span><br><span class="line">subject.next(&#123; <span class="attr">age</span>: <span class="number">25</span> &#125;); </span><br><span class="line">subject.next(&#123; <span class="attr">favoriteLanguage</span>: <span class="string">'JavaScript'</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> avg = Observable.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  .scan(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      sum: prev.sum + cur,</span><br><span class="line">      count: prev.count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; <span class="attr">sum</span>: <span class="number">0</span>, <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  .subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Average is: '</span>, x);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="reduce-累加-同scan-但只打印最后的结果"><a href="#reduce-累加-同scan-但只打印最后的结果" class="headerlink" title="reduce 累加 同scan  但只打印最后的结果"></a>reduce 累加 同scan  但只打印最后的结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> avg = Observable.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  .reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      sum: prev.sum + cur,</span><br><span class="line">      count: prev.count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; <span class="attr">sum</span>: <span class="number">0</span>, <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  .subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Average is: '</span>, x);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="distinct-去重"><a href="#distinct-去重" class="headerlink" title="distinct  去重"></a>distinct  去重</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">  .distinct()</span><br><span class="line">  .subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>
<h3 id="distinctUntilChanged-去除连续重复值"><a href="#distinctUntilChanged-去除连续重复值" class="headerlink" title="distinctUntilChanged 去除连续重复值"></a>distinctUntilChanged 去除连续重复值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>)</span><br><span class="line">  .distinctUntilChanged( )</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>
<h3 id="distinctKeyUntilChanged-去除连续项中key值相同的项"><a href="#distinctKeyUntilChanged-去除连续项中key值相同的项" class="headerlink" title="distinctKeyUntilChanged 去除连续项中key值相同的项"></a>distinctKeyUntilChanged 去除连续项中key值相同的项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [</span><br><span class="line">  &#123; <span class="attr">k</span>: <span class="number">1</span>, <span class="attr">v</span>: <span class="string">'leon'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">k</span>: <span class="number">2</span>, <span class="attr">v</span>: <span class="string">'rina'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">k</span>: <span class="number">3</span>, <span class="attr">v</span>: <span class="string">'rina'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">k</span>: <span class="number">4</span>, <span class="attr">v</span>: <span class="string">'leon'</span> &#125;</span><br><span class="line">]</span><br><span class="line">Observable.of(...list)</span><br><span class="line">  .distinctUntilKeyChanged(<span class="string">'v'</span>)</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure>
<h3 id="elementAt-输出下标中值"><a href="#elementAt-输出下标中值" class="headerlink" title="elementAt  输出下标中值"></a>elementAt  输出下标中值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>)</span><br><span class="line">  .elementAt( <span class="number">3</span> )</span><br><span class="line">  .subscribe( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log( x ))</span><br></pre></td></tr></table></figure>

    
  </div>
</article>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/05/12/leaving/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/07/22/rxjs-in-use/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'leonzhang1108';
    
    var disqus_url = 'http://6rina.cc/2017/07/22/rxjs/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//leonzhang1108.disqus.com/count.js" async></script>



    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
